"""
Export Service – Multi-Format Document Generation
──────────────────────────────────────────────────
Converts verified Markdown text into PDF, DOCX, or raw Markdown files.
"""

from __future__ import annotations

import io
import logging
import re
from typing import Optional

logger = logging.getLogger(__name__)


def _md_to_plain(md_text: str) -> str:
    """Strip basic Markdown formatting for plain-text export."""
    text = re.sub(r"#{1,6}\s*", "", md_text)  # headings
    text = re.sub(r"\*\*(.+?)\*\*", r"\1", text)  # bold
    text = re.sub(r"\*(.+?)\*", r"\1", text)  # italic
    text = re.sub(r"_(.+?)_", r"\1", text)  # italic
    text = re.sub(r"`(.+?)`", r"\1", text)  # inline code
    text = re.sub(r"^\s*[-*+]\s", "- ", text, flags=re.MULTILINE)  # bullets
    return text.strip()


def export_markdown(text: str, title: str = "OmniDraft Note") -> bytes:
    """Return raw Markdown bytes."""
    header = f"# {title}\n\n"
    return (header + text).encode("utf-8")


def export_txt(text: str, title: str = "OmniDraft Note") -> bytes:
    """Return plain text bytes."""
    plain = _md_to_plain(text)
    header = f"{title}\n{'=' * len(title)}\n\n"
    return (header + plain).encode("utf-8")


def export_pdf(text: str, title: str = "OmniDraft Note") -> bytes:
    """Generate a highly styled, professional PDF from the transcription text."""
    from fpdf import FPDF
    from fpdf.enums import XPos, YPos
    import os
    
    # Colors (Professional Palette)
    PRIMARY_COLOR = (43, 61, 79)    # Deep Indigo/Steel
    ACCENT_COLOR = (52, 152, 219)   # Bright Professional Blue
    TEXT_COLOR = (44, 62, 80)       # Dark Slate
    GREY_TEXT = (127, 140, 141)     # Soft Grey
    BG_LIGHT = (250, 250, 250)      # Very Light Background
    BORDER_COLOR = (236, 240, 241)  # Thin/Subtle border
    
    # Resolve fonts
    current_dir = os.path.dirname(os.path.abspath(__file__))
    fonts_dir = os.path.join(current_dir, "..", "fonts")
    font_regular = os.path.join(fonts_dir, "NotoSans-Regular.ttf")
    font_bold = os.path.join(fonts_dir, "NotoSans-Bold.ttf")
    font_telugu = os.path.join(fonts_dir, "NotoSansTelugu-Regular.ttf")

    class ScribePDF(FPDF):
        def header(self):
            # Header bar (subtle top line)
            self.set_draw_color(*PRIMARY_COLOR)
            self.set_line_width(0.5)
            self.line(10, 10, 200, 10)
            
            self.set_y(15)
            self.set_font("NotoSans", "B", 10)
            self.set_text_color(*PRIMARY_COLOR)
            self.cell(40, 8, "OmniDraft", align="L")
            
            self.set_font("NotoSans", "", 9)
            self.set_text_color(*GREY_TEXT)
            self.cell(0, 8, "Handwriting Architecture Intelligence", align="R")
            self.ln(15)

        def footer(self):
            self.set_y(-15)
            # Subtle footer line
            self.set_draw_color(*BORDER_COLOR)
            self.set_line_width(0.2)
            self.line(10, self.h - 15, 200, self.h - 15)
            
            self.set_font("NotoSans", "", 8)
            self.set_text_color(*GREY_TEXT)
            self.cell(0, 10, f"Generated by OmniDraft – {self.page_no()} / {{nb}}", align="R")

    pdf = ScribePDF()
    pdf.alias_nb_pages()
    pdf.set_auto_page_break(auto=True, margin=20)

    # Add Unicode fonts
    pdf.add_font("NotoSans", "", font_regular)
    pdf.add_font("NotoSans", "B", font_bold)
    pdf.add_font("NotoSans", "I", font_regular) # fallback for italic
    pdf.add_font("NotoSansTelugu", "", font_telugu)
    
    pdf.set_fallback_fonts(["NotoSansTelugu"])
    pdf.set_text_shaping(True)
    pdf.add_page()

    # Title Section (Modern/Hero style)
    pdf.set_y(30)
    pdf.set_draw_color(*ACCENT_COLOR)
    pdf.set_line_width(1)
    pdf.line(10, pdf.get_y(), 30, pdf.get_y()) # Accent bar
    pdf.ln(5)
    
    pdf.set_font("NotoSans", "B", 24)
    pdf.set_text_color(*PRIMARY_COLOR)
    pdf.multi_cell(0, 15, title, new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    
    pdf.set_font("NotoSans", "", 10)
    pdf.set_text_color(*ACCENT_COLOR)
    from datetime import datetime
    pdf.cell(0, 8, f"Document Exported: {datetime.now().strftime('%B %d, %Y')}", new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    pdf.ln(10)

    # Divider line
    pdf.set_draw_color(*BORDER_COLOR)
    pdf.set_line_width(0.5)
    pdf.line(10, pdf.get_y(), 200, pdf.get_y())
    pdf.ln(10)

    # Body formatting
    pdf.set_font("NotoSans", "", 11)
    pdf.set_text_color(*TEXT_COLOR)

    # Split by blocks/paragraphs
    blocks = re.split(r'\n\s*\n', text.strip())
    
    for block in blocks:
        block = block.strip()
        if not block:
            continue
            
        # 1. Heading Recognition
        heading_match = re.match(r"^(#{1,6})\s+(.*)$", block, flags=re.MULTILINE|re.DOTALL)
        if heading_match and "\n" not in heading_match.group(2):
            level = len(heading_match.group(1))
            heading_text = heading_match.group(2).replace("\n", " ").strip()
            
            pdf.ln(6)
            size = max(11, 22 - (level * 2))
            pdf.set_font("NotoSans", "B", size)
            pdf.set_text_color(*PRIMARY_COLOR)
            
            # Sub-bar for H1
            if level == 1:
                pdf.set_draw_color(*ACCENT_COLOR)
                pdf.set_line_width(0.5)
                pdf.multi_cell(0, size * 0.5, heading_text, new_x=XPos.LMARGIN, new_y=YPos.NEXT, markdown=True)
                pdf.line(pdf.get_x(), pdf.get_y(), 200, pdf.get_y())
                pdf.ln(2)
            else:
                pdf.multi_cell(0, size * 0.5, heading_text, new_x=XPos.LMARGIN, new_y=YPos.NEXT, markdown=True)
            pdf.ln(3)
            continue
            
        # 2. Blockquotes Recognition (e.g. > Quote)
        if block.startswith(">"):
            pdf.ln(2)
            pdf.set_fill_color(*BG_LIGHT)
            pdf.set_draw_color(*ACCENT_COLOR)
            pdf.set_line_width(1)
            
            quote_lines = [l.strip().lstrip(">").strip() for l in block.split("\n")]
            quote_text = " ".join(quote_lines)
            
            # Draw side bar
            x, y = pdf.get_x(), pdf.get_y()
            pdf.set_font("NotoSans", "I", 11)
            pdf.set_text_color(100, 100, 110)
            
            # We calculate height roughly to draw the side bar
            with pdf.offset_rendering() as dummy:
                dummy.multi_cell(0, 6, quote_text, markdown=True)
                height = dummy.y - y
            
            pdf.line(x, y, x, y + height + 4)
            pdf.set_x(x + 5)
            pdf.multi_cell(0, 6, quote_text, fill=True, new_x=XPos.LMARGIN, new_y=YPos.NEXT, markdown=True)
            pdf.ln(5)
            continue

        # 3. Enhanced Table Recognition
        if "\n" in block and "|" in block.split("\n")[0] and "|" in block.split("\n")[1]:
            lines = block.split("\n")
            pdf.ln(4)
            pdf.set_font("NotoSans", "", 10)
            
            # fpdf2 built-in table with custom styling
            with pdf.table(
                text_align="LEFT", 
                line_height=5, 
                padding=2,
                gutter_height=0,
                borders_layout="HORIZONTAL_LINES"
            ) as table:
                for i, line in enumerate(lines):
                    # Skip the markdown separator row
                    if set(line.strip().replace(" ", "").replace("|", "").replace("-", "")) == set():
                        continue
                    
                    cells = [c.strip() for c in line.strip().strip("|").split("|")]
                    row_ctx = table.row()
                    for cell in cells:
                        if i == 0: # Header style
                            pdf.set_font("NotoSans", "B", 10)
                            pdf.set_text_color(255, 255, 255)
                            row_ctx.cell(cell, background_color=PRIMARY_COLOR)
                        else: # Body style
                            pdf.set_font("NotoSans", "", 10)
                            pdf.set_text_color(*TEXT_COLOR)
                            # Alternating row background
                            bg = BG_LIGHT if i % 2 == 0 else (255, 255, 255)
                            row_ctx.cell(cell, background_color=bg)
            pdf.ln(6)
            continue
            
        # 4. Code Block Recognition
        if block.startswith("```") and block.endswith("```"):
            code_content = block[3:-3].strip()
            if "\n" in code_content:
                first_line, rest = code_content.split("\n", 1)
                if not " " in first_line:
                    code_content = rest
            
            pdf.ln(2)
            pdf.set_font("Courier", "", 9)
            pdf.set_text_color(70, 70, 70)
            pdf.set_fill_color(248, 249, 250)
            pdf.set_draw_color(*BORDER_COLOR)
            pdf.set_line_width(0.1)
            
            pdf.multi_cell(0, 5, code_content, fill=True, border=1, new_x=XPos.LMARGIN, new_y=YPos.NEXT, markdown=False)
            pdf.ln(4)
            continue
            
        # 5. List Recognition
        if block.startswith("- ") or block.startswith("* ") or re.match(r"^\d+\.\s+", block):
            pdf.ln(2)
            lines = block.split("\n")
            for line in lines:
                line = line.strip()
                if not line: continue
                
                pdf.set_font("NotoSans", "", 11)
                pdf.set_text_color(*TEXT_COLOR)
                
                if line.startswith("- ") or line.startswith("* "): # Bullet
                    content = line[2:].strip()
                    pdf.set_x(15)
                    pdf.set_font("NotoSans", "B", 11)
                    pdf.set_text_color(*ACCENT_COLOR)
                    pdf.cell(5, 6, "\u2022") # Bullets point in Accent Blue
                    pdf.set_font("NotoSans", "", 11)
                    pdf.set_text_color(*TEXT_COLOR)
                    pdf.multi_cell(0, 6, content, new_x=XPos.LMARGIN, new_y=YPos.NEXT, markdown=True)
                elif re.match(r"^(\d+\.)\s+(.*)", line): # Numbered
                    match = re.match(r"^(\d+\.)\s+(.*)", line)
                    pdf.set_x(15)
                    pdf.set_font("NotoSans", "B", 11)
                    pdf.set_text_color(*ACCENT_COLOR)
                    pdf.cell(8, 6, match.group(1))
                    pdf.set_font("NotoSans", "", 11)
                    pdf.set_text_color(*TEXT_COLOR)
                    pdf.multi_cell(0, 6, match.group(2).strip(), new_x=XPos.LMARGIN, new_y=YPos.NEXT, markdown=True)
                else: # Continuation
                    pdf.set_x(23)
                    pdf.multi_cell(0, 6, line, new_x=XPos.LMARGIN, new_y=YPos.NEXT, markdown=True)
            pdf.ln(4)
            continue
            
        # 6. Regular Paragraph
        paragraph_text = block.replace("\n", " ").strip()
        pdf.set_font("NotoSans", "", 11)
        pdf.set_text_color(*TEXT_COLOR)
        pdf.multi_cell(0, 7, paragraph_text, new_x=XPos.LMARGIN, new_y=YPos.NEXT, markdown=True)
        pdf.ln(4)

    return bytes(pdf.output())


def export_docx(text: str, title: str = "OmniDraft Note") -> bytes:
    """Generate a styled DOCX from the transcription text."""
    from docx import Document
    from docx.shared import Inches, Pt, RGBColor
    from docx.enum.text import WD_ALIGN_PARAGRAPH

    doc = Document()

    # Style the title
    title_para = doc.add_heading(title, level=0)
    for run in title_para.runs:
        run.font.color.rgb = RGBColor(30, 30, 30)

    # Add a subtle horizontal rule
    rule_para = doc.add_paragraph()
    rule_para.paragraph_format.space_after = Pt(12)
    rule_run = rule_para.add_run("─" * 60)
    rule_run.font.color.rgb = RGBColor(70, 130, 180)
    rule_run.font.size = Pt(8)

    # Body text – construct formatted markdown elements logically by paragraph/block
    blocks = re.split(r'\n\s*\n', text.strip())
    
    for block in blocks:
        block = block.strip()
        if not block:
            continue

        # 1. Headings
        heading_match = re.match(r"^(#{1,6})\s+(.*)$", block, flags=re.MULTILINE|re.DOTALL)
        if heading_match and "\n" not in heading_match.group(2):
            level = min(len(heading_match.group(1)), 4)
            heading_text = heading_match.group(2).replace("\n", " ").strip()
            doc.add_heading(heading_text, level=level)
            continue

        # 2. Tables
        if "\n" in block and "|" in block.split("\n")[0] and "|" in block.split("\n")[1]:
            lines = block.split("\n")
            # find number of columns from first row
            header_cells = [c.strip() for c in lines[0].strip().strip("|").split("|")]
            table = doc.add_table(rows=0, cols=len(header_cells))
            table.style = 'Table Grid'
            
            for i, line in enumerate(lines):
                # Skip the markdown separator row (e.g. |---|---|)
                if set(line.strip().replace(" ", "").replace("|", "").replace("-", "")) == set():
                    continue
                
                cells = [c.strip() for c in line.strip().strip("|").split("|")]
                row_cells = table.add_row().cells
                for j, cell in enumerate(cells):
                    if j < len(row_cells):
                        row_cells[j].text = cell
                        if i == 0:  # Bold headers
                            for paragraph in row_cells[j].paragraphs:
                                for run in paragraph.runs:
                                    run.bold = True
            doc.add_paragraph("") # Space after table
            continue

        # 3. Code blocks
        if block.startswith("```") and block.endswith("```"):
            code_content = block[3:-3].strip()
            if "\n" in code_content:
                first_line, rest = code_content.split("\n", 1)
                if not " " in first_line:
                    code_content = rest
            
            para = doc.add_paragraph(code_content)
            for run in para.runs:
                run.font.name = "Courier New"
                run.font.size = Pt(9)
                run.font.color.rgb = RGBColor(80, 80, 80)
            continue

        # 4. List block (Bullet / Numbered)
        if block.startswith("- ") or block.startswith("* ") or re.match(r"^\d+\.\s+", block):
            lines = block.split("\n")
            for line in lines:
                line = line.strip()
                if not line: continue
                # Bullet
                if line.startswith("- ") or line.startswith("* "):
                    content = line[2:].strip()
                    doc.add_paragraph(content, style="List Bullet")
                # Numbered
                elif re.match(r"^(\d+\.)\s+(.*)", line):
                    match = re.match(r"^(\d+\.)\s+(.*)", line)
                    doc.add_paragraph(match.group(2).strip(), style="List Number")
                else:
                    doc.add_paragraph(line)
            continue

        # 5. Regular paragraph
        paragraph_text = block.replace("\n", " ").strip()
        para = doc.add_paragraph()
        
        # Handle bold and italic in-line
        segments = re.split(r"(\*\*.*?\*\*|\*.*?\*|_.*?_|`.*?`)", paragraph_text)
        for seg in segments:
            if seg.startswith("**") and seg.endswith("**"):
                run = para.add_run(seg[2:-2])
                run.bold = True
            elif (seg.startswith("*") and seg.endswith("*")) or \
                 (seg.startswith("_") and seg.endswith("_")):
                run = para.add_run(seg[1:-1])
                run.italic = True
            elif seg.startswith("`") and seg.endswith("`"):
                run = para.add_run(seg[1:-1])
                run.font.name = "Courier New"
                run.font.size = Pt(10)
                run.font.color.rgb = RGBColor(180, 60, 60)
            else:
                para.add_run(seg)

    buf = io.BytesIO()
    doc.save(buf)
    return buf.getvalue()


def export_note(
    text: str,
    format: str,
    title: str = "OmniDraft Note",
) -> tuple[bytes, str, str]:
    """
    Export a note to the requested format.

    Returns (file_bytes, content_type, file_extension).
    """
    format_lower = format.lower().strip(".")

    exporters = {
        "pdf": (export_pdf, "application/pdf", ".pdf"),
        "docx": (export_docx, "application/vnd.openxmlformats-officedocument.wordprocessingml.document", ".docx"),
        "md": (export_markdown, "text/markdown", ".md"),
        "markdown": (export_markdown, "text/markdown", ".md"),
        "txt": (export_txt, "text/plain", ".txt"),
    }

    if format_lower not in exporters:
        raise ValueError(f"Unsupported format: {format}. Supported: {list(exporters.keys())}")

    func, content_type, ext = exporters[format_lower]
    file_bytes = func(text, title)
    return file_bytes, content_type, ext
